# Gregorian calendar algorithms

## Improving instruction level parallelism of division and modular calculations.

Example 3.12 of [[1]](#EAF-arxiv) provides an alternative for the evaluations of `q = n / 1461` and
`r = n % 1461`, claiming it foster instruction-level parallelism implemented by superscalar
processors and they profit from the backward compatibility features that drove the design of the
x86_64 instruction set. This document provides more details about these claims.

We want to compare the throughput of the traditional and alternative evaluations. Their C++ and
corresponding assembly listings (generated by
[clang 11.0.0](https://godbolt.org/z/ePbfKM) with `-O3`) are:

<table>
<tbody>
<tr>
<td colspan="2">
<b>Traditional</b>
</td>
</tr>
<tr>
<td>

```c++
void div_mod_1461(uint32_t n) {
    uint32_t const q = n / 1461;

    uint32_t const r = n % 1461;

}
```
</td>
<td>

```assembly
mov eax, edi
imul rax, rax, 376287347
shr rax, 39
imul ecx, eax, 1461
sub edi, ecx

```
</td>
</tr>
<tr style="text-align: center;">
<td colspan="2">
<b>Alternative</b> (valid for all n ∈ [0, 28 825 529[)
</td>
</tr>
<td>

```c++
void div_mod_1461(uint32_t n) {
  uint64_t const p = uint64_t(2939745) * n;

  uint32_t const q = p >> 32;
  uint32_t const r = uint32_t(p) / 2939745;
  // ...
}
```

</td>
<td>

```assembly
mov eax, edi
imul rax, rax, 2939745
mov ecx, eax
shr rax, 32
imul rcx, rcx, 1531969483
shr rcx, 52
```

</td>
</tr>

</tbody>
</table>

In the traditional implementation, the compiler replaces `n / 1461` with `(n * 376287347) >> 39`
(2<sup>nd</sup> and 3<sup>rd</sup> assembly lines) as per [[2]](#GranlundMontgomery). The resulting
`q` is stored at `rax`. Then `r` is evaluated through the expression `r = n - 1461 * q`
(4<sup>th</sup> and 5<sup>th</sup> assembly lines, where `q` is stored in `eax`, a sort of "alias"
of `rax`). Therefore, although not obvious in the C++ code, there is a data dependency forcing the
CPU to wait the calculation of `q` to finish before it starts that of `r`. Notice also the usage of
`edi` at the first and last lines. This indicates another kind of data dependency and `edi` is
"locked" holding the value of `n` during the entire execution of the code.

The alternative implementation does not suffer from these problems as we shall see. But first things
first. Similarly to tradional's assembly, `q` is evaluated by a product and a right bitwise shift:
`(n * 2939745) >> 32`. However, this strengh reduction is done manually in C++ rather than relying
on the compiler which would, otherwise, choose 39 bits instead of 32. We prefer the latter because
x86_64 implements special treatment of 32 bits data (more on that later) to support backward
compatibility with x86 ISA. The compiler has good reasons to choose 39 bits though: it avoids the
limitation n ∈ [0, 28 825 529[ of the alternative. It depends on the application whether this
limitation is material or not. (The interval is large enough, for instance, for our Gregorian
calendar algorithms so we do use the alternative.)

In contrast to the traditional's C++ listing, the alternative's does not hid a dependency of `r` on
`q`. This dependency does not exist but both `q` and `r` depedend on `p`. Therefore, their
calculations require `p` to be stored in two different registers and hence, the `mov ecx, eax`. This
makes the alternative's listing longer than the traditional's (6 instructions as opposed to 5) but
this extra instruction is a worthwhile price to pay for breaking the data dependency. The other
issue of the traditional code about `edi` being blocked is clearly absent in the alternative code.

We used the [LLVM Machine Code Analyser](https://www.llvm.org/docs/CommandGuide/llvm-mca.html) to
assess the throughput of the two assembly listings. Simulating 100 iterations for the
[traditional](https://godbolt.org/z/hGcE11) and [alternative](https://godbolt.org/z/Mqzv6z)
implementations we obtain

Result       |Traditional | Alternative
-------------|-----------:|-----------:
Iterations   | 100        | 100
Instructions | 500        | 600
Total Cycles | 903        | 207
Total uOps   | 500        | 600

Although, as expected, the traditional implementation executes 500 instructions (5 per iteration)
and the alternative does 600 (6 per iteration), the former takes 903 cycles whereas the latter takes
207. This is a considerable increase in throughput. (To be honest, I find this result "to good to
be true" and I cannot totally understand it. Any help would be appreciated.) Further confirmation
comes from looking at the timelines. For the last instruction (#4 for traditional and #5 for
alternative) of iteration #7 they are as below:

| Implementation | Timeline                                                                    |
|----------------|-----------------------------------------------------------------------------|
| Traditional    | [7,4] D=================================================================eER |
| Alternative    | [7,5] D============eER                                                      |

Each character represents what the CPU does doing for this particular instruction during each cycle.
According to the [manual](https://www.llvm.org/docs/CommandGuide/llvm-mca.html#timeline-view)

| Characther | Meaning                                                 |
|------------|---------------------------------------------------------|
| D          | Instruction dispatched.                                 |
| e          | Instruction executing.                                  |
| E          | Instruction executed.                                   |
| R          | Instruction retired.                                    |
| =          | Instruction already dispatched, waiting to be executed. |

The most noticeable fact is that for the traditional implementation the CPU waits 65 cycles (the 65
'=' characters) to exectute the instruction. The alternative waited only 12 cycles.

Finally, as said in [[1]](#EAF-arxiv), the alternative requires evaluating `p % 2³²` (done in C++
above through the cast `uint32_t(p)`) but this comes for free since (thanks to the backward
compatibility with x86 ISA) `mov ecx, eax` resets the 32 most significant bits of `rcx` (effectively
performing a `mov` and `% 2³²` in a single instruction). (Unfortunately,
[gcc 10.2](https://godbolt.org/z/vjv56E) adds `mov edi, edi` to reset the 32 most significant bits
of `rdi`.)


## Acknowledgment

Many thanks to Fabio Fernandes for providing interesting insights on this matter.

## References

<span id="EAF-arxiv">[1] Cassio Neri and Lorenz Schneider.
*Euclidean Affine Functions and Applications to Calendar Algorithms*.
[Preprint](https://arxiv.org/abs/2102.06959), February 2021.<br>
</span>

<span id="GranlundMontgomery">[2] Torbjörn Granlund and Peter L. Montgomery.
*Division by invariant integers using multiplication*.
In Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation,
PLDI ’94, pages 61–72, New York, NY, USA, 1994.
Association for Computing Machinery.
[doi.org/10.1145/178243.178249](http://doi.org/10.1145/178243.178249).
</span>
