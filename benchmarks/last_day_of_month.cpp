/*******************************************************************************
 *
 * las_day_of_month benchmarks
 *
 * Copyright (C) 2020 Cassio Neri and Lorenz Schneider
 *
 * This file is part of https://github.com/cassioneri/calendar.
 *
 * This file is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This file is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this file. If not, see <https://www.gnu.org/licenses/>.
 *
 ******************************************************************************/

#include <cstdint>
#include <random>

//------------------------------------------------------------------------------
// Config
//------------------------------------------------------------------------------

using year_t  = std::int16_t; // as in std::chrono::year
using month_t = std::uint8_t; // as in std::chrono::month
using day_t   = std::uint8_t; // as in std::chrono::day

//------------------------------------------------------------------------------
// Implementations
//------------------------------------------------------------------------------

namespace neri_schneider {

  // https://github.com/cassioneri/calendar/blob/master/calendar.hpp

  bool constexpr
  is_multiple_of_100(std::int32_t n) {
    std::uint32_t constexpr multiplier   = 42949673;
    std::uint32_t constexpr bound        = 42949669;
    std::uint32_t constexpr max_dividend = 1073741799;
    std::uint32_t constexpr offset       = max_dividend / 2 / 100 * 100;
    return multiplier * (n + offset) < bound;
  }

  bool constexpr
  is_leap_year(year_t year) noexcept {
    return (!is_multiple_of_100(year) || year % 16 == 0) & (year % 4 == 0);
  }

  day_t constexpr
  last_day_of_month(year_t year, month_t month) noexcept {
    return month != 2 ? ((month ^ (month >> 3)) & 1) | 30 :
      is_leap_year(year) ? 29 : 28;
  }

} // namespace neri_schneider

namespace boost {

  // Code in this namespace is subject to the following terms.

  // Copyright (c) 2002,2003 CrystalClear Software, Inc.

  // Boost Software License - Version 1.0 - August 17th, 2003

  // Permission is hereby granted, free of charge, to any person or organization
  // obtaining a copy of the software and accompanying documentation covered by
  // this license (the "Software") to use, reproduce, display, distribute,
  // execute, and transmit the Software, and to prepare derivative works of the
  // Software, and to permit third-parties to whom the Software is furnished to
  // do so, all subject to the following:

  // The copyright notices in the Software and this entire statement, including
  // the above license grant, this restriction and the following disclaimer,
  // must be included in all copies of the Software, in whole or in part, and
  // all derivative works of the Software, unless such copies or derivative
  // works are solely in the form of machine-executable object code generated by
  // a source language processor.

  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  // SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  // FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  // ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  // DEALINGS IN THE SOFTWARE.

  // https://github.com/boostorg/date_time/blob/4e1b7cde45edf8fdda73ec5c60053c9257138292/include/boost/date_time/gregorian_calendar.ipp#L161
  bool constexpr
  is_leap_year(year_t year) {
    return (!(year % 4))  && ((year % 100) || (!(year % 400)));
  }

  // https://github.com/boostorg/date_time/blob/4e1b7cde45edf8fdda73ec5c60053c9257138292/include/boost/date_time/gregorian_calendar.ipp#L175
  day_t constexpr
  last_day_of_month(year_t year, month_t month) noexcept {
    switch (month) {
    case 2:
      if (is_leap_year(year)) {
        return 29;
      } else {
        return 28;
      };
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
    default:
      return 31;
    };
  }

} // namespace boost

namespace llvm {

  // Code in this namespace is subject to the following terms.

  // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
  // See https://llvm.org/LICENSE.txt for license information.

  // https://github.com/llvm/llvm-project/blob/8e34be2f2511dfff7a8e3018bbd4188a93e446ea/libcxx/include/chrono#L1777
  bool constexpr
  is_leap_year(year_t __y) noexcept {
    return __y % 4 == 0 && (__y % 100 != 0 || __y % 400 == 0);
  }

  // https://github.com/llvm/llvm-project/blob/8e34be2f2511dfff7a8e3018bbd4188a93e446ea/libcxx/include/chrono#L2447
  day_t constexpr
  last_day_of_month(year_t __y, month_t month) noexcept {
    day_t constexpr __d[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    return month != 2 || !is_leap_year(__y) ?
        __d[static_cast<unsigned>(month - 1)] : day_t{29};
  }

} // namespace llvm

//-------------------------------------------------------------------
// Benchmark data
//-------------------------------------------------------------------

auto const years = [](){
  std::uniform_int_distribution<year_t> uniform_dist(-400, 399);
  std::mt19937 rng;
  std::array<year_t, 16384> years;
  for (auto& year : years)
    year = uniform_dist(rng);
  return years;
}();

auto const months = [](){
  std::uniform_int_distribution<month_t> uniform_dist(1, 12);
  std::mt19937 rng;
  std::array<month_t, 16384> months;
  for (auto& month : months)
    month = uniform_dist(rng);
  return months;
}();

//------------------------------------------------------------------------------
// Benchmark
//------------------------------------------------------------------------------

void Boost(benchmark::State& state) {
  for (auto _ : state) {
    for (std::int32_t i = 0; i < 16384; ++i) {
      auto day = boost::last_day_of_month(years[i], months[i]);
      benchmark::DoNotOptimize(day);
    }
  }
}
BENCHMARK(Boost);

void LLVM(benchmark::State& state) {
  for (auto _ : state) {
    for (std::int32_t i = 0; i < 16384; ++i) {
      auto day = llvm::last_day_of_month(years[i], months[i]);
      benchmark::DoNotOptimize(day);
    }
  }
}
BENCHMARK(LLVM);

void NeriSchhneider(benchmark::State& state) {
  for (auto _ : state) {
    for (std::int32_t i = 0; i < 16384; ++i) {
      auto day = neri_schneider::last_day_of_month(years[i], months[i]);
      benchmark::DoNotOptimize(day);
    }
  }
}
BENCHMARK(NeriSchhneider);
